# 100 Задач по Абстракции в Dart

## Уровень 1: Базовые концепции (Задачи 1-10)

### Задача 1: Интерфейс и реализация
Создайте абстрактный класс `Shape` с методом `getArea()`. Реализуйте класс `Circle` с этим методом.

```dart
// Решение
abstract class Shape {
  double getArea();
}

class Circle implements Shape {
  double radius;
  Circle(this.radius);
  
  @override
  double getArea() => 3.14 * radius * radius;
}
```

### Задача 2: Абстрактный метод без реализации
Создайте абстрактный класс `Animal` с методом `sound()` и класс `Dog`, который выводит "Woof!".

### Задача 3: Множественная реализация интерфейса
Создайте интерфейс `Drawable` и реализуйте его в классах `Rectangle` и `Triangle`.

### Задача 4: Абстрактный класс с полями
Создайте абстрактный класс `Vehicle` с полем `speed` и абстрактным методом `accelerate()`.

### Задача 5: Простое наследование
Создайте класс `Parent` и класс `Child`, который наследует `Parent` и переопределяет метод `greet()`.

### Задача 6: Интерфейс с несколькими методами
Создайте интерфейс `Calculator` с методами `add()`, `subtract()`, `multiply()`.

### Задача 7: Абстрактный класс с конструктором
Создайте абстрактный класс `Person` с конструктором, инициализирующим имя и фамилию.

### Задача 8: Полиморфизм через список
Создайте список объектов типа `Shape` и выведите площадь каждой фигуры.

### Задача 9: Переопределение `toString()`
Создайте класс `Book` и переопределите метод `toString()` для вывода информации о книге.

### Задача 10: Абстрактное свойство
Создайте абстрактный класс с абстрактным геттером `name` и реализуйте его в подклассе.

---

## Уровень 2: Средние задачи (Задачи 11-30)

### Задача 11: Цепочка наследования
Создайте цепочку: `Animal` -> `Mammal` -> `Dog` с переопределением методов на каждом уровне.

### Задача 12: Миксины (Mixins)
Создайте миксин `Flying` и применить его к классу `Bird`.

```dart
mixin Flying {
  void fly() => print("Flying...");
}

class Bird with Flying {
  void makeSound() => print("Chirp!");
}
```

### Задача 13: Интерфейс с реализацией по умолчанию
Создайте интерфейс `Logger` с реализацией по умолчанию и переопределение в подклассе.

### Задача 14: Абстрактный класс с конкретными методами
Создайте абстрактный класс `DatabaseConnection` с абстрактным методом `connect()` и конкретным методом `getVersion()`.

### Задача 15: Полиморфный вызов методов
Создайте массив различных типов `Employee` и выведите зарплату каждого.

### Задача 16: Интерфейс и абстрактный класс вместе
Создайте интерфейс `Comparable` и абстрактный класс `ComparableObject`, реализующий его.

### Задача 17: Параметризованный интерфейс
Создайте интерфейс `Container<T>` с методами добавления и получения элементов.

### Задача 18: Множественная реализация интерфейсов
Создайте класс, реализующий два интерфейса одновременно.

### Задача 19: Абстрактное свойство с сеттером
Создайте абстрактный класс с абстрактным свойством, которое можно изменять.

### Задача 20: Переопределение оператора сравнения
Переопределите оператор `==` в классе `Student` для сравнения по ID.

### Задача 21: Абстрактный класс с статическими методами
Создайте абстрактный класс `Math` со статическими методами.

### Задача 22: Интерфейс с циклом наследования
Создайте интерфейсы `A` и `B`, которые наследуются друг от друга корректно.

### Задача 23: Полиморфизм с обработкой исключений
Создайте интерфейс `Parser` и реализации, которые выбрасывают исключения при ошибке.

### Задача 24: Абстрактный класс с приватными методами
Создайте абстрактный класс с приватным методом для использования подклассами.

### Задача 25: Factory-конструктор в абстрактном классе
Создайте абстрактный класс `Shape` с factory-конструктором `Shape.fromString()`.

### Задача 26: Нахождение типа объекта
Создайте функцию, которая определяет тип переданного объекта и вызывает соответствующий метод.

### Задача 27: Реализация Iterator
Создайте класс, реализующий интерфейс `Iterator` для перебора коллекции.

### Задача 28: Абстрактный класс с конструктором для подклассов
Создайте абстрактный класс, требующий от подклассов вызвать конструктор родителя.

### Задача 29: Интерфейс для обработки ошибок
Создайте интерфейс `ErrorHandler` с различными реализациями для разных типов ошибок.

### Задача 30: Полиморфный контейнер
Создайте контейнер, который может хранить различные типы объектов, реализующих интерфейс.

---

## Уровень 3: Продвинутые задачи (Задачи 31-60)

### Задача 31: Генерики с абстрактными классами
Создайте абстрактный класс `Repository<T>` с методом `findById(int id) -> T`.

```dart
abstract class Repository<T> {
  T? findById(int id);
  List<T> findAll();
}
```

### Задача 32: Ограничения типов (Type Bounds)
Создайте абстрактный класс с ограничением типа: `class Container<T extends Comparable>`.

### Задача 33: Комбинирование интерфейсов и миксинов
Создайте класс, который реализует интерфейс и использует миксин одновременно.

### Задача 34: Асинхронные абстрактные методы
Создайте абстрактный класс с абстрактным методом `Future<String> fetchData()`.

### Задача 35: Стратегия (Strategy Pattern)
Реализуйте паттерн Strategy с различными алгоритмами сортировки.

### Задача 36: Наблюдатель (Observer Pattern)
Создайте систему уведомлений с интерфейсом `Observer` и `Subject`.

### Задача 37: Декоратор (Decorator Pattern)
Создайте класс, оборачивающий другой класс и добавляющий функциональность.

### Задача 38: Фабрика (Factory Pattern)
Создайте фабрику для создания различных типов объектов на основе параметра.

### Задача 39: Синглтон с интерфейсом
Создайте синглтон, реализующий определенный интерфейс.

### Задача 40: Адаптер (Adapter Pattern)
Создайте адаптер, который преобразует один интерфейс в другой.

### Задача 41: Мост (Bridge Pattern)
Реализуйте паттерн Bridge, разделяющий абстракцию и реализацию.

### Задача 42: Композиция над наследованием
Создайте класс, который использует композицию вместо наследования для реализации функциональности.

### Задача 43: Полиморфное сохранение состояния
Создайте систему сохранения объектов различных типов в коллекцию.

### Задача 44: Обработка исключений в иерархии классов
Создайте иерархию исключений и их обработка в абстрактном классе.

### Задача 45: Constraints и Variance
Создайте генерик с ковариантными и контравариантными типами.

### Задача 46: Интерфейс с методом копирования
Создайте интерфейс `Cloneable` и реализуйте глубокое копирование.

### Задача 47: Абстрактный класс для обработки данных
Создайте `DataProcessor<T>` с методами фильтрации, трансформации и загрузки данных.

### Задача 48: Слушатели событий (Event Listeners)
Создайте систему событий с абстрактным классом `EventListener`.

### Задача 49: Цепь обработки (Chain of Responsibility)
Реализуйте цепь обработки запросов через абстрактные классы.

### Задача 50: Шаблонный метод (Template Method Pattern)
Создайте абстрактный класс с методом-шаблоном, вызывающим абстрактные методы.

### Задача 51: Интерфейс для валидации
Создайте интерфейс `Validator<T>` и реализации для различных типов данных.

### Задача 52: Абстрактный класс для построения объектов (Builder)
Создайте построитель с абстрактными методами для конфигурации.

### Задача 53: Полиморфный вывод в JSON
Создайте интерфейс `Serializable` с методом преобразования в JSON.

### Задача 54: Абстрактный класс с потоком (Stream)
Создайте `StreamProcessor` с методом обработки потока данных.

### Задача 55: Интерфейс для работы с файлами
Создайте интерфейс `FileStorage` с методами чтения и записи для разных форматов.

### Задача 56: Полиморфная валидация формы
Создайте систему валидации с абстрактным классом `FormValidator`.

### Задача 57: Абстрактный класс для логирования
Создайте `Logger` с различными реализациями (файл, консоль, сеть).

### Задача 58: Интерфейс для кэширования
Создайте интерфейс `Cache<K, V>` с операциями get, set, clear.

### Задача 59: Абстрактный класс для HTTP-клиента
Создайте `HttpClient` с методами GET, POST, PUT, DELETE.

### Задача 60: Полиморфная работа с базой данных
Создайте интерфейс `Database` с реализациями для SQL и NoSQL.

---

## Уровень 4: Экспертные задачи (Задачи 61-100)

### Задача 61: Параметризованные миксины
Создайте миксин с типовым параметром для добавления кэширования.

```dart
mixin Cacheable<T> {
  Map<String, T> _cache = {};
  
  void cache(String key, T value) => _cache[key] = value;
  T? getFromCache(String key) => _cache[key];
}
```

### Задача 62: Множественное наследование через интерфейсы
Создайте сложную иерархию интерфейсов и классов.

### Задача 63: Абстрактный класс с невариантными типами
Создайте класс, строго соблюдающий типы в иерархии.

### Задача 64: Функциональные интерфейсы
Создайте интерфейс с одним методом и используйте как функцию.

```dart
abstract class Function1<T, R> {
  R call(T value);
}

class Square implements Function1<int, int> {
  @override
  int call(int value) => value * value;
}
```

### Задача 65: Обобщенные ограничения типов
Создайте `Cache<T extends Comparable>` с методом сортировки.

### Задача 66: Метапрограммирование через рефлексию
Используйте зеркала (mirrors) для работы с абстрактными классами.

### Задача 67: Условное наследование через интерфейсы
Создайте систему прав доступа на основе интерфейсов.

### Задача 68: Полиморфное сравнение объектов
Реализуйте интерфейс `Comparable` с корректным сравнением.

### Задача 69: Асинхронная обработка через интерфейсы
Создайте интерфейс для асинхронной работы с Future и Stream.

### Задача 70: Интерфейс для плагинов
Разработайте систему плагинов с интерфейсом `Plugin`.

### Задача 71: Абстрактный класс для конвертации типов
Создайте `Converter<From, To>` для преобразования между типами.

### Задача 72: Полиморфная система отчетов
Создайте интерфейс `Report` с различными форматами (PDF, Excel, CSV).

### Задача 73: Абстрактный класс для машины состояний
Создайте `StateMachine` с абстрактными методами переходов.

### Задача 74: Интерфейс для оптимизации
Создайте интерфейс `Optimizer<T>` для оптимизации данных.

### Задача 75: Полиморфное управление ресурсами
Реализуйте интерфейс `Resource` с методом `dispose()`.

### Задача 76: Абстрактный класс для обработки платежей
Создайте `PaymentGateway` с методами обработки различных типов платежей.

### Задача 77: Интерфейс для работы с API
Создайте интерфейс `ApiClient` с методами для REST операций.

### Задача 78: Полиморфная кэширование с TTL
Расширьте `Cache` функциональностью истечения времени жизни.

### Задача 79: Абстрактный класс для правил бизнес-логики
Создайте `BusinessRule` для проверки различных условий.

### Задача 80: Интерфейс для аудита
Создайте систему аудита с интерфейсом `AuditLog`.

### Задача 81: Полиморфная обработка конфигураций
Создайте интерфейс `Config` для различных источников конфиг.

### Задача 82: Абстрактный класс для миграций БД
Создайте `Migration` с методами `up()` и `down()`.

### Задача 83: Интерфейс для middleware
Разработайте систему middleware для обработки запросов.

### Задача 84: Полиморфная система уведомлений
Создайте `Notification` с различными каналами доставки.

### Задача 85: Абстрактный класс для очереди задач
Создайте `JobQueue` для обработки асинхронных задач.

### Задача 86: Интерфейс для хеширования паролей
Создайте интерфейс `PasswordHasher` с различными алгоритмами.

### Задача 87: Полиморфная система прав доступа
Создайте `Permission` и `PermissionChecker` для управления доступом.

### Задача 88: Абстрактный класс для поиска
Создайте `SearchEngine<T>` с различными стратегиями поиска.

### Задача 89: Интерфейс для фильтрации данных
Создайте `Filter<T>` с комбинированием фильтров.

### Задача 90: Полиморфная система зависимостей
Реализуйте простой DI контейнер с интерфейсом `Container`.

### Задача 91: Абстрактный класс для обработки ошибок приложения
Создайте `ErrorHandler` с логированием и восстановлением.

### Задача 92: Интерфейс для метрик и мониторинга
Создайте интерфейс `Metrics` для сбора и анализа данных.

### Задача 93: Полиморфная система кешей с разными стратегиями вытеснения
Реализуйте LRU, LFU и FIFO кэши через интерфейс.

### Задача 94: Абстрактный класс для обработки изображений
Создайте `ImageProcessor` с фильтрами и трансформациями.

### Задача 95: Интерфейс для работы с графами
Создайте интерфейс `Graph<T>` для различных реализаций графов.

### Задача 96: Полиморфная система валидации с правилами
Создайте `RuleValidator` с цепочкой правил валидации.

### Задача 97: Абстрактный класс для работы с временными периодами
Создайте `Period` для различных типов периодов (день, неделя, месяц).

### Задача 98: Интерфейс для асинхронных операций с отменой
Создайте `AsyncOperation<T>` с поддержкой отмены.

### Задача 99: Полиморфная система кодирования/декодирования
Создайте `Codec<T>` для различных форматов (JSON, Base64, гриф).

### Задача 100: Мегазадача: Фреймворк для управления сущностями
Создайте фреймворк с интерфейсом `Entity`, `Repository<T>`, `Service<T>`, включающий:
- Абстрактные методы CRUD операций
- Полиморфное кэширование
- Систему прав доступа
- Логирование операций
- Валидацию данных
- Обработку ошибок
- Асинхронную обработку

```dart
// Пример структуры решения
abstract class Entity {
  int get id;
  DateTime get createdAt;
  DateTime get updatedAt;
}

abstract class Repository<T extends Entity> {
  Future<T?> findById(int id);
  Future<List<T>> findAll();
  Future<void> save(T entity);
  Future<void> delete(int id);
}

abstract class Service<T extends Entity, R extends Repository<T>> {
  final R repository;
  Service(this.repository);
  
  Future<T> getEntity(int id);
  Future<List<T>> getAllEntities();
  Future<void> createEntity(T entity);
  Future<void> updateEntity(T entity);
  Future<void> removeEntity(int id);
}
```

---

## Подсказки для решения

### Ключевые концепции:
1. **Абстрактный класс** - класс, который не может быть инстанцирован напрямую
2. **Интерфейс** - контракт методов, которые должны быть реализованы
3. **Наследование** - использование кода родительского класса
4. **Полиморфизм** - способность объекта принимать различные формы
5. **Миксины** - способ переиспользования кода между классами
6. **Генерики** - типобезопасная работа с различными типами данных
7. **Паттерны проектирования** - проверенные решения архитектурных проблем

### Инструменты отладки:
- `is` - проверка типа объекта
- `as` - приведение типа объекта
- `runtimeType` - получение типа объекта во время выполнения
- `implements` - реализация интерфейса
- `extends` - наследование класса

---

## Рекомендуемый порядок обучения

1. **Дни 1-2**: Задачи 1-10 (базовые концепции)
2. **Дни 3-5**: Задачи 11-30 (средний уровень с паттернами)
3. **Дни 6-10**: Задачи 31-60 (продвинутые техники)
4. **Дни 11-15**: Задачи 61-100 (экспертные решения)

Для каждой задачи рекомендуется:
- Прочитать описание
- Попытаться решить самостоятельно (20-30 минут)
- Проверить решение
- Модифицировать и экспериментировать